====================[ Build | analysis ]========================================
make --jobs=9 analysis
module load gcc/8.2.0 && gcc -Wall -std=gnu11 -Werror -Wextra -fopenmp -O2 -ftree-vectorize -fopt-info-vec-all analysis.c -o analysis
  Loading gcc/8.2.0

Analyzing loop at analysis.c:31
analysis.c:31:2: note: ===== analyze_loop_nest =====
analysis.c:31:2: note: === vect_analyze_loop_form ===
analysis.c:31:2: note: === get_loop_niters ===
analysis.c:31:2: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at analysis.c:27
analysis.c:27:2: note: ===== analyze_loop_nest =====
analysis.c:27:2: note: === vect_analyze_loop_form ===
analysis.c:27:2: note: === get_loop_niters ===
analysis.c:27:2: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at analysis.c:22
analysis.c:22:2: note: ===== analyze_loop_nest =====
analysis.c:22:2: note: === vect_analyze_loop_form ===
analysis.c:22:2: note: === get_loop_niters ===
analysis.c:22:2: note: === vect_analyze_data_refs ===
analysis.c:22:2: note: got vectype for stmt: _6 = a[_5];
vector(4) int
analysis.c:22:2: note: not vectorized: not suitable for gather load _6 = a[_5];
analysis.c:22:2: note: bad data references.

Analyzing loop at analysis.c:18
analysis.c:18:2: note: ===== analyze_loop_nest =====
analysis.c:18:2: note: === vect_analyze_loop_form ===
analysis.c:18:2: note: === get_loop_niters ===
analysis.c:18:2: note: === vect_analyze_data_refs ===
analysis.c:18:2: note: got vectype for stmt: _4 = a[i_61];
vector(4) int
analysis.c:18:2: note: got vectype for stmt: a[_3] = _4;
vector(4) int
analysis.c:18:2: note: === vect_analyze_scalar_cycles ===
analysis.c:18:2: note: Analyze phi: i_61 = PHI <4(13), i_30(18)>
analysis.c:18:2: note: Access function of PHI: {4, +, 1}_3
analysis.c:18:2: note: step: 1,  init: 4
analysis.c:18:2: note: Detected induction.
analysis.c:18:2: note: Analyze phi: .MEM_67 = PHI <.MEM_27(13), .MEM_29(18)>
analysis.c:18:2: note: Analyze phi: ivtmp_13 = PHI <1020(13), ivtmp_12(18)>
analysis.c:18:2: note: Access function of PHI: {1020, +, 4294967295}_3
analysis.c:18:2: note: step: 4294967295,  init: 1020
analysis.c:18:2: note: Detected induction.
analysis.c:18:2: note: === vect_pattern_recog ===
analysis.c:18:2: note: === vect_analyze_data_ref_accesses ===
analysis.c:18:2: note: === vect_mark_stmts_to_be_vectorized ===
analysis.c:18:2: note: init: phi relevant? i_61 = PHI <4(13), i_30(18)>
analysis.c:18:2: note: init: phi relevant? .MEM_67 = PHI <.MEM_27(13), .MEM_29(18)>
analysis.c:18:2: note: init: phi relevant? ivtmp_13 = PHI <1020(13), ivtmp_12(18)>
analysis.c:18:2: note: init: stmt relevant? _3 = i_61 + -4;
analysis.c:18:2: note: init: stmt relevant? _4 = a[i_61];
analysis.c:18:2: note: init: stmt relevant? a[_3] = _4;
analysis.c:18:2: note: vec_stmt_relevant_p: stmt has vdefs.
analysis.c:18:2: note: mark relevant 5, live 0: a[_3] = _4;
analysis.c:18:2: note: init: stmt relevant? i_30 = i_61 + 1;
analysis.c:18:2: note: init: stmt relevant? ivtmp_12 = ivtmp_13 - 1;
analysis.c:18:2: note: init: stmt relevant? if (ivtmp_12 != 0)
analysis.c:18:2: note: worklist: examine stmt: a[_3] = _4;
analysis.c:18:2: note: vect_is_simple_use: operand _4
analysis.c:18:2: note: def_stmt: _4 = a[i_61];
analysis.c:18:2: note: type of def: internal
analysis.c:18:2: note: mark relevant 5, live 0: _4 = a[i_61];
analysis.c:18:2: note: worklist: examine stmt: _4 = a[i_61];
analysis.c:18:2: note: === vect_analyze_data_ref_dependences ===
analysis.c:18:2: note: dependence distance  = 4.
analysis.c:18:2: note: dependence distance negative.
analysis.c:18:2: note: === vect_determine_vectorization_factor ===
analysis.c:18:2: note: ==> examining phi: i_61 = PHI <4(13), i_30(18)>
analysis.c:18:2: note: ==> examining phi: .MEM_67 = PHI <.MEM_27(13), .MEM_29(18)>
analysis.c:18:2: note: ==> examining phi: ivtmp_13 = PHI <1020(13), ivtmp_12(18)>
analysis.c:18:2: note: ==> examining statement: _3 = i_61 + -4;
analysis.c:18:2: note: skip.
analysis.c:18:2: note: ==> examining statement: _4 = a[i_61];
analysis.c:18:2: note: get vectype for scalar type:  int
analysis.c:18:2: note: vectype: vector(4) int
analysis.c:18:2: note: nunits = 4
analysis.c:18:2: note: ==> examining statement: a[_3] = _4;
analysis.c:18:2: note: get vectype for scalar type:  int
analysis.c:18:2: note: vectype: vector(4) int
analysis.c:18:2: note: nunits = 4
analysis.c:18:2: note: ==> examining statement: i_30 = i_61 + 1;
analysis.c:18:2: note: skip.
analysis.c:18:2: note: ==> examining statement: ivtmp_12 = ivtmp_13 - 1;
analysis.c:18:2: note: skip.
analysis.c:18:2: note: ==> examining statement: if (ivtmp_12 != 0)
analysis.c:18:2: note: skip.
analysis.c:18:2: note: vectorization factor = 4
analysis.c:18:2: note: === vect_analyze_slp ===
analysis.c:18:2: note: === vect_make_slp_decision ===
analysis.c:18:2: note: vectorization_factor = 4, niters = 1020
analysis.c:18:2: note: === vect_analyze_data_refs_alignment ===
analysis.c:18:2: note: accesses have the same alignment: a[i_61] and a[_3]
analysis.c:18:2: note: recording new base alignment for &a
analysis.c:18:2: note:   alignment:    16
analysis.c:18:2: note:   misalignment: 0
analysis.c:18:2: note:   based on:     _4 = a[i_61];
analysis.c:18:2: note: vect_compute_data_ref_alignment:
analysis.c:18:2: note: misalign = 0 bytes of ref a[i_61]
analysis.c:18:2: note: vect_compute_data_ref_alignment:
analysis.c:18:2: note: misalign = 0 bytes of ref a[_3]
analysis.c:18:2: note: === vect_prune_runtime_alias_test_list ===
analysis.c:18:2: note: === vect_enhance_data_refs_alignment ===
analysis.c:18:2: note: vect_can_advance_ivs_p:
analysis.c:18:2: note: Analyze phi: i_61 = PHI <4(13), i_30(18)>
analysis.c:18:2: note: Analyze phi: .MEM_67 = PHI <.MEM_27(13), .MEM_29(18)>
analysis.c:18:2: note: reduc or virtual phi. skip.
analysis.c:18:2: note: Analyze phi: ivtmp_13 = PHI <1020(13), ivtmp_12(18)>
analysis.c:18:2: note: vect_model_load_cost: aligned.
analysis.c:18:2: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
analysis.c:18:2: note: vect_model_store_cost: aligned.
analysis.c:18:2: note: vect_get_data_access_cost: inside_cost = 24, outside_cost = 0.
analysis.c:18:2: note: === vect_analyze_loop_operations ===
analysis.c:18:2: note: examining phi: i_61 = PHI <4(13), i_30(18)>
analysis.c:18:2: note: examining phi: .MEM_67 = PHI <.MEM_27(13), .MEM_29(18)>
analysis.c:18:2: note: examining phi: ivtmp_13 = PHI <1020(13), ivtmp_12(18)>
analysis.c:18:2: note: ==> examining statement: _3 = i_61 + -4;
analysis.c:18:2: note: irrelevant.
analysis.c:18:2: note: ==> examining statement: _4 = a[i_61];
analysis.c:18:2: note: num. args = 4 (not unary/binary/ternary op).
analysis.c:18:2: note: vect_is_simple_use: operand a[i_61]
analysis.c:18:2: note: not ssa-name.
analysis.c:18:2: note: use not simple.
analysis.c:18:2: note: can't use a fully-masked loop because the target doesn't have the appropriate masked load or store.
analysis.c:18:2: note: vect_model_load_cost: aligned.
analysis.c:18:2: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
analysis.c:18:2: note: ==> examining statement: a[_3] = _4;
analysis.c:18:2: note: vect_is_simple_use: operand _4
analysis.c:18:2: note: def_stmt: _4 = a[i_61];
analysis.c:18:2: note: type of def: internal
analysis.c:18:2: note: vect_model_store_cost: aligned.
analysis.c:18:2: note: vect_model_store_cost: inside_cost = 12, prologue_cost = 0 .
analysis.c:18:2: note: ==> examining statement: i_30 = i_61 + 1;
analysis.c:18:2: note: irrelevant.
analysis.c:18:2: note: ==> examining statement: ivtmp_12 = ivtmp_13 - 1;
analysis.c:18:2: note: irrelevant.
analysis.c:18:2: note: ==> examining statement: if (ivtmp_12 != 0)
analysis.c:18:2: note: irrelevant.
analysis.c:18:2: note: not using a fully-masked loop.
analysis.c:18:2: note: Cost model analysis:
  Vector inside of loop cost: 24
  Vector prologue cost: 0
  Vector epilogue cost: 0
  Scalar iteration cost: 24
  Scalar outside cost: 0
  Vector outside cost: 0
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 0
analysis.c:18:2: note:   Runtime profitability threshold = 4
analysis.c:18:2: note:   Static estimate profitability threshold = 4
analysis.c:18:2: note: loop vectorized
analysis.c:18:2: note: === vec_transform_loop ===
analysis.c:18:2: note: ------>vectorizing phi: i_61 = PHI <i_30(18), 4(21)>
analysis.c:18:2: note: ------>vectorizing phi: .MEM_67 = PHI <.MEM_29(18), .MEM_27(21)>
analysis.c:18:2: note: ------>vectorizing phi: ivtmp_13 = PHI <ivtmp_12(18), 1020(21)>
analysis.c:18:2: note: ------>vectorizing statement: _3 = i_61 + -4;
analysis.c:18:2: note: ------>vectorizing statement: _4 = a[i_61];
analysis.c:18:2: note: transform statement.
analysis.c:18:2: note: transform load. ncopies = 1
analysis.c:18:2: note: create vector_type-pointer variable to type: vector(4) int  vectorizing an array ref: a
analysis.c:18:2: note: created vectp_a.1_58
analysis.c:18:2: note: add new stmt: vect__4.2_52 = MEM[(int *)vectp_a.0_56];
analysis.c:18:2: note: ------>vectorizing statement: a[_3] = _4;
analysis.c:18:2: note: transform statement.
analysis.c:18:2: note: vect_is_simple_use: operand _4
analysis.c:18:2: note: def_stmt: _4 = a[i_61];
analysis.c:18:2: note: type of def: internal
analysis.c:18:2: note: transform store. ncopies = 1
analysis.c:18:2: note: vect_get_vec_def_for_operand: _4
analysis.c:18:2: note: vect_is_simple_use: operand _4
analysis.c:18:2: note: def_stmt: _4 = a[i_61];
analysis.c:18:2: note: type of def: internal
analysis.c:18:2: note:   def_stmt =  _4 = a[i_61];
analysis.c:18:2: note: create vector_type-pointer variable to type: vector(4) int  vectorizing an array ref: a
analysis.c:18:2: note: created &a
analysis.c:18:2: note: add new stmt: MEM[(int *)vectp_a.3_50] = vect__4.2_52;
analysis.c:18:2: note: ------>vectorizing statement: i_30 = i_61 + 1;
analysis.c:18:2: note: ------>vectorizing statement: ivtmp_12 = ivtmp_13 - 1;
analysis.c:18:2: note: ------>vectorizing statement: vectp_a.0_54 = vectp_a.0_56 + 16;
analysis.c:18:2: note: ------>vectorizing statement: vectp_a.3_48 = vectp_a.3_50 + 16;
analysis.c:18:2: note: ------>vectorizing statement: if (ivtmp_12 != 0)
analysis.c:18:2: note: New loop exit condition: if (ivtmp_18 < 255)
analysis.c:18:2: note: LOOP VECTORIZED


Analyzing loop at analysis.c:14
analysis.c:14:2: note: ===== analyze_loop_nest =====
analysis.c:14:2: note: === vect_analyze_loop_form ===
analysis.c:14:2: note: === get_loop_niters ===
analysis.c:14:2: note: === vect_analyze_data_refs ===
analysis.c:14:2: note: got vectype for stmt: _2 = a[i_60];
vector(4) int
analysis.c:14:2: note: got vectype for stmt: b[i_60] = _2;
vector(4) int
analysis.c:14:2: note: === vect_analyze_scalar_cycles ===
analysis.c:14:2: note: Analyze phi: i_60 = PHI <0(14), i_28(19)>
analysis.c:14:2: note: Access function of PHI: {0, +, 1}_2
analysis.c:14:2: note: step: 1,  init: 0
analysis.c:14:2: note: Detected induction.
analysis.c:14:2: note: Analyze phi: .MEM_66 = PHI <.MEM_25(14), .MEM_27(19)>
analysis.c:14:2: note: Analyze phi: ivtmp_11 = PHI <1024(14), ivtmp_10(19)>
analysis.c:14:2: note: Access function of PHI: {1024, +, 4294967295}_2
analysis.c:14:2: note: step: 4294967295,  init: 1024
analysis.c:14:2: note: Detected induction.
analysis.c:14:2: note: === vect_pattern_recog ===
analysis.c:14:2: note: === vect_analyze_data_ref_accesses ===
analysis.c:14:2: note: === vect_mark_stmts_to_be_vectorized ===
analysis.c:14:2: note: init: phi relevant? i_60 = PHI <0(14), i_28(19)>
analysis.c:14:2: note: init: phi relevant? .MEM_66 = PHI <.MEM_25(14), .MEM_27(19)>
analysis.c:14:2: note: init: phi relevant? ivtmp_11 = PHI <1024(14), ivtmp_10(19)>
analysis.c:14:2: note: init: stmt relevant? _2 = a[i_60];
analysis.c:14:2: note: init: stmt relevant? b[i_60] = _2;
analysis.c:14:2: note: vec_stmt_relevant_p: stmt has vdefs.
analysis.c:14:2: note: mark relevant 5, live 0: b[i_60] = _2;
analysis.c:14:2: note: init: stmt relevant? i_28 = i_60 + 1;
analysis.c:14:2: note: init: stmt relevant? ivtmp_10 = ivtmp_11 - 1;
analysis.c:14:2: note: init: stmt relevant? if (ivtmp_10 != 0)
analysis.c:14:2: note: worklist: examine stmt: b[i_60] = _2;
analysis.c:14:2: note: vect_is_simple_use: operand _2
analysis.c:14:2: note: def_stmt: _2 = a[i_60];
analysis.c:14:2: note: type of def: internal
analysis.c:14:2: note: mark relevant 5, live 0: _2 = a[i_60];
analysis.c:14:2: note: worklist: examine stmt: _2 = a[i_60];
analysis.c:14:2: note: === vect_analyze_data_ref_dependences ===
analysis.c:14:2: note: === vect_determine_vectorization_factor ===
analysis.c:14:2: note: ==> examining phi: i_60 = PHI <0(14), i_28(19)>
analysis.c:14:2: note: ==> examining phi: .MEM_66 = PHI <.MEM_25(14), .MEM_27(19)>
analysis.c:14:2: note: ==> examining phi: ivtmp_11 = PHI <1024(14), ivtmp_10(19)>
analysis.c:14:2: note: ==> examining statement: _2 = a[i_60];
analysis.c:14:2: note: get vectype for scalar type:  int
analysis.c:14:2: note: vectype: vector(4) int
analysis.c:14:2: note: nunits = 4
analysis.c:14:2: note: ==> examining statement: b[i_60] = _2;
analysis.c:14:2: note: get vectype for scalar type:  int
analysis.c:14:2: note: vectype: vector(4) int
analysis.c:14:2: note: nunits = 4
analysis.c:14:2: note: ==> examining statement: i_28 = i_60 + 1;
analysis.c:14:2: note: skip.
analysis.c:14:2: note: ==> examining statement: ivtmp_10 = ivtmp_11 - 1;
analysis.c:14:2: note: skip.
analysis.c:14:2: note: ==> examining statement: if (ivtmp_10 != 0)
analysis.c:14:2: note: skip.
analysis.c:14:2: note: vectorization factor = 4
analysis.c:14:2: note: === vect_analyze_slp ===
analysis.c:14:2: note: === vect_make_slp_decision ===
analysis.c:14:2: note: vectorization_factor = 4, niters = 1024
analysis.c:14:2: note: === vect_analyze_data_refs_alignment ===
analysis.c:14:2: note: recording new base alignment for &a
analysis.c:14:2: note:   alignment:    16
analysis.c:14:2: note:   misalignment: 0
analysis.c:14:2: note:   based on:     _2 = a[i_60];
analysis.c:14:2: note: recording new base alignment for &b
analysis.c:14:2: note:   alignment:    16
analysis.c:14:2: note:   misalignment: 0
analysis.c:14:2: note:   based on:     b[i_60] = _2;
analysis.c:14:2: note: vect_compute_data_ref_alignment:
analysis.c:14:2: note: misalign = 0 bytes of ref a[i_60]
analysis.c:14:2: note: vect_compute_data_ref_alignment:
analysis.c:14:2: note: misalign = 0 bytes of ref b[i_60]
analysis.c:14:2: note: === vect_prune_runtime_alias_test_list ===
analysis.c:14:2: note: === vect_enhance_data_refs_alignment ===
analysis.c:14:2: note: vect_can_advance_ivs_p:
analysis.c:14:2: note: Analyze phi: i_60 = PHI <0(14), i_28(19)>
analysis.c:14:2: note: Analyze phi: .MEM_66 = PHI <.MEM_25(14), .MEM_27(19)>
analysis.c:14:2: note: reduc or virtual phi. skip.
analysis.c:14:2: note: Analyze phi: ivtmp_11 = PHI <1024(14), ivtmp_10(19)>
analysis.c:14:2: note: vect_model_load_cost: aligned.
analysis.c:14:2: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
analysis.c:14:2: note: vect_model_store_cost: aligned.
analysis.c:14:2: note: vect_get_data_access_cost: inside_cost = 24, outside_cost = 0.
analysis.c:14:2: note: === vect_analyze_loop_operations ===
analysis.c:14:2: note: examining phi: i_60 = PHI <0(14), i_28(19)>
analysis.c:14:2: note: examining phi: .MEM_66 = PHI <.MEM_25(14), .MEM_27(19)>
analysis.c:14:2: note: examining phi: ivtmp_11 = PHI <1024(14), ivtmp_10(19)>
analysis.c:14:2: note: ==> examining statement: _2 = a[i_60];
analysis.c:14:2: note: num. args = 4 (not unary/binary/ternary op).
analysis.c:14:2: note: vect_is_simple_use: operand a[i_60]
analysis.c:14:2: note: not ssa-name.
analysis.c:14:2: note: use not simple.
analysis.c:14:2: note: can't use a fully-masked loop because the target doesn't have the appropriate masked load or store.
analysis.c:14:2: note: vect_model_load_cost: aligned.
analysis.c:14:2: note: vect_model_load_cost: inside_cost = 12, prologue_cost = 0 .
analysis.c:14:2: note: ==> examining statement: b[i_60] = _2;
analysis.c:14:2: note: vect_is_simple_use: operand _2
analysis.c:14:2: note: def_stmt: _2 = a[i_60];
analysis.c:14:2: note: type of def: internal
analysis.c:14:2: note: vect_model_store_cost: aligned.
analysis.c:14:2: note: vect_model_store_cost: inside_cost = 12, prologue_cost = 0 .
analysis.c:14:2: note: ==> examining statement: i_28 = i_60 + 1;
analysis.c:14:2: note: irrelevant.
analysis.c:14:2: note: ==> examining statement: ivtmp_10 = ivtmp_11 - 1;
analysis.c:14:2: note: irrelevant.
analysis.c:14:2: note: ==> examining statement: if (ivtmp_10 != 0)
analysis.c:14:2: note: irrelevant.
analysis.c:14:2: note: not using a fully-masked loop.
analysis.c:14:2: note: Cost model analysis:
  Vector inside of loop cost: 24
  Vector prologue cost: 0
  Vector epilogue cost: 0
  Scalar iteration cost: 24
  Scalar outside cost: 0
  Vector outside cost: 0
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 0
analysis.c:14:2: note:   Runtime profitability threshold = 4
analysis.c:14:2: note:   Static estimate profitability threshold = 4
analysis.c:14:2: note: loop vectorized
analysis.c:14:2: note: === vec_transform_loop ===
analysis.c:14:2: note: ------>vectorizing phi: i_60 = PHI <i_28(19), 0(22)>
analysis.c:14:2: note: ------>vectorizing phi: .MEM_66 = PHI <.MEM_27(19), .MEM_25(22)>
analysis.c:14:2: note: ------>vectorizing phi: ivtmp_11 = PHI <ivtmp_10(19), 1024(22)>
analysis.c:14:2: note: ------>vectorizing statement: _2 = a[i_60];
analysis.c:14:2: note: transform statement.
analysis.c:14:2: note: transform load. ncopies = 1
analysis.c:14:2: note: create vector_type-pointer variable to type: vector(4) int  vectorizing an array ref: a
analysis.c:14:2: note: created &a
analysis.c:14:2: note: add new stmt: vect__2.7_15 = MEM[(int *)vectp_a.5_17];
analysis.c:14:2: note: ------>vectorizing statement: b[i_60] = _2;
analysis.c:14:2: note: transform statement.
analysis.c:14:2: note: vect_is_simple_use: operand _2
analysis.c:14:2: note: def_stmt: _2 = a[i_60];
analysis.c:14:2: note: type of def: internal
analysis.c:14:2: note: transform store. ncopies = 1
analysis.c:14:2: note: vect_get_vec_def_for_operand: _2
analysis.c:14:2: note: vect_is_simple_use: operand _2
analysis.c:14:2: note: def_stmt: _2 = a[i_60];
analysis.c:14:2: note: type of def: internal
analysis.c:14:2: note:   def_stmt =  _2 = a[i_60];
analysis.c:14:2: note: create vector_type-pointer variable to type: vector(4) int  vectorizing an array ref: b
analysis.c:14:2: note: created &b
analysis.c:14:2: note: add new stmt: MEM[(int *)vectp_b.8_46] = vect__2.7_15;
analysis.c:14:2: note: ------>vectorizing statement: i_28 = i_60 + 1;
analysis.c:14:2: note: ------>vectorizing statement: ivtmp_10 = ivtmp_11 - 1;
analysis.c:14:2: note: ------>vectorizing statement: vectp_a.5_16 = vectp_a.5_17 + 16;
analysis.c:14:2: note: ------>vectorizing statement: vectp_b.8_45 = vectp_b.8_46 + 16;
analysis.c:14:2: note: ------>vectorizing statement: if (ivtmp_10 != 0)
analysis.c:14:2: note: New loop exit condition: if (ivtmp_42 < 256)
analysis.c:14:2: note: LOOP VECTORIZED


Analyzing loop at analysis.c:10
analysis.c:10:2: note: ===== analyze_loop_nest =====
analysis.c:10:2: note: === vect_analyze_loop_form ===
analysis.c:10:2: note: === get_loop_niters ===
analysis.c:10:2: note: === vect_analyze_data_refs ===
analysis.c:10:2: note: got vectype for stmt: a[i_59] = argc_24(D);
vector(4) int
analysis.c:10:2: note: === vect_analyze_scalar_cycles ===
analysis.c:10:2: note: Analyze phi: i_59 = PHI <0(2), i_26(20)>
analysis.c:10:2: note: Access function of PHI: {0, +, 1}_1
analysis.c:10:2: note: step: 1,  init: 0
analysis.c:10:2: note: Detected induction.
analysis.c:10:2: note: Analyze phi: .MEM_65 = PHI <.MEM_23(2), .MEM_25(20)>
analysis.c:10:2: note: Analyze phi: ivtmp_9 = PHI <1024(2), ivtmp_57(20)>
analysis.c:10:2: note: Access function of PHI: {1024, +, 4294967295}_1
analysis.c:10:2: note: step: 4294967295,  init: 1024
analysis.c:10:2: note: Detected induction.
analysis.c:10:2: note: === vect_pattern_recog ===
analysis.c:10:2: note: === vect_analyze_data_ref_accesses ===
analysis.c:10:2: note: === vect_mark_stmts_to_be_vectorized ===
analysis.c:10:2: note: init: phi relevant? i_59 = PHI <0(2), i_26(20)>
analysis.c:10:2: note: init: phi relevant? .MEM_65 = PHI <.MEM_23(2), .MEM_25(20)>
analysis.c:10:2: note: init: phi relevant? ivtmp_9 = PHI <1024(2), ivtmp_57(20)>
analysis.c:10:2: note: init: stmt relevant? a[i_59] = argc_24(D);
analysis.c:10:2: note: vec_stmt_relevant_p: stmt has vdefs.
analysis.c:10:2: note: mark relevant 5, live 0: a[i_59] = argc_24(D);
analysis.c:10:2: note: init: stmt relevant? i_26 = i_59 + 1;
analysis.c:10:2: note: init: stmt relevant? ivtmp_57 = ivtmp_9 - 1;
analysis.c:10:2: note: init: stmt relevant? if (ivtmp_57 != 0)
analysis.c:10:2: note: worklist: examine stmt: a[i_59] = argc_24(D);
analysis.c:10:2: note: vect_is_simple_use: operand argc_24(D)
analysis.c:10:2: note: === vect_analyze_data_ref_dependences ===
analysis.c:10:2: note: === vect_determine_vectorization_factor ===
analysis.c:10:2: note: ==> examining phi: i_59 = PHI <0(2), i_26(20)>
analysis.c:10:2: note: ==> examining phi: .MEM_65 = PHI <.MEM_23(2), .MEM_25(20)>
analysis.c:10:2: note: ==> examining phi: ivtmp_9 = PHI <1024(2), ivtmp_57(20)>
analysis.c:10:2: note: ==> examining statement: a[i_59] = argc_24(D);
analysis.c:10:2: note: get vectype for scalar type:  int
analysis.c:10:2: note: vectype: vector(4) int
analysis.c:10:2: note: nunits = 4
analysis.c:10:2: note: ==> examining statement: i_26 = i_59 + 1;
analysis.c:10:2: note: skip.
analysis.c:10:2: note: ==> examining statement: ivtmp_57 = ivtmp_9 - 1;
analysis.c:10:2: note: skip.
analysis.c:10:2: note: ==> examining statement: if (ivtmp_57 != 0)
analysis.c:10:2: note: skip.
analysis.c:10:2: note: vectorization factor = 4
analysis.c:10:2: note: === vect_analyze_slp ===
analysis.c:10:2: note: === vect_make_slp_decision ===
analysis.c:10:2: note: vectorization_factor = 4, niters = 1024
analysis.c:10:2: note: === vect_analyze_data_refs_alignment ===
analysis.c:10:2: note: recording new base alignment for &a
analysis.c:10:2: note:   alignment:    16
analysis.c:10:2: note:   misalignment: 0
analysis.c:10:2: note:   based on:     a[i_59] = argc_24(D);
analysis.c:10:2: note: vect_compute_data_ref_alignment:
analysis.c:10:2: note: misalign = 0 bytes of ref a[i_59]
analysis.c:10:2: note: === vect_prune_runtime_alias_test_list ===
analysis.c:10:2: note: === vect_enhance_data_refs_alignment ===
analysis.c:10:2: note: vect_can_advance_ivs_p:
analysis.c:10:2: note: Analyze phi: i_59 = PHI <0(2), i_26(20)>
analysis.c:10:2: note: Analyze phi: .MEM_65 = PHI <.MEM_23(2), .MEM_25(20)>
analysis.c:10:2: note: reduc or virtual phi. skip.
analysis.c:10:2: note: Analyze phi: ivtmp_9 = PHI <1024(2), ivtmp_57(20)>
analysis.c:10:2: note: vect_model_store_cost: aligned.
analysis.c:10:2: note: vect_get_data_access_cost: inside_cost = 12, outside_cost = 0.
analysis.c:10:2: note: === vect_analyze_loop_operations ===
analysis.c:10:2: note: examining phi: i_59 = PHI <0(2), i_26(20)>
analysis.c:10:2: note: examining phi: .MEM_65 = PHI <.MEM_23(2), .MEM_25(20)>
analysis.c:10:2: note: examining phi: ivtmp_9 = PHI <1024(2), ivtmp_57(20)>
analysis.c:10:2: note: ==> examining statement: a[i_59] = argc_24(D);
analysis.c:10:2: note: vect_is_simple_use: operand argc_24(D)
analysis.c:10:2: note: can't use a fully-masked loop because the target doesn't have the appropriate masked load or store.
analysis.c:10:2: note: vect_model_store_cost: aligned.
analysis.c:10:2: note: vect_model_store_cost: inside_cost = 12, prologue_cost = 4 .
analysis.c:10:2: note: ==> examining statement: i_26 = i_59 + 1;
analysis.c:10:2: note: irrelevant.
analysis.c:10:2: note: ==> examining statement: ivtmp_57 = ivtmp_9 - 1;
analysis.c:10:2: note: irrelevant.
analysis.c:10:2: note: ==> examining statement: if (ivtmp_57 != 0)
analysis.c:10:2: note: irrelevant.
analysis.c:10:2: note: not using a fully-masked loop.
analysis.c:10:2: note: Cost model analysis:
  Vector inside of loop cost: 12
  Vector prologue cost: 4
  Vector epilogue cost: 0
  Scalar iteration cost: 12
  Scalar outside cost: 0
  Vector outside cost: 4
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 1
analysis.c:10:2: note:   Runtime profitability threshold = 4
analysis.c:10:2: note:   Static estimate profitability threshold = 4
analysis.c:10:2: note: loop vectorized
analysis.c:10:2: note: === vec_transform_loop ===
analysis.c:10:2: note: ------>vectorizing phi: i_59 = PHI <i_26(20), 0(23)>
analysis.c:10:2: note: ------>vectorizing phi: .MEM_65 = PHI <.MEM_25(20), .MEM_23(23)>
analysis.c:10:2: note: ------>vectorizing phi: ivtmp_9 = PHI <ivtmp_57(20), 1024(23)>
analysis.c:10:2: note: ------>vectorizing statement: a[i_59] = argc_24(D);
analysis.c:10:2: note: transform statement.
analysis.c:10:2: note: vect_is_simple_use: operand argc_24(D)
analysis.c:10:2: note: transform store. ncopies = 1
analysis.c:10:2: note: vect_get_vec_def_for_operand: argc_24(D)
analysis.c:10:2: note: vect_is_simple_use: operand argc_24(D)
analysis.c:10:2: note: created new init_stmt: vect_cst__41 = {argc_24(D), argc_24(D), argc_24(D), argc_24(D)};
analysis.c:10:2: note: create vector_type-pointer variable to type: vector(4) int  vectorizing an array ref: a
analysis.c:10:2: note: created &a
analysis.c:10:2: note: add new stmt: MEM[(int *)vectp_a.10_71] = vect_cst__41;
analysis.c:10:2: note: ------>vectorizing statement: i_26 = i_59 + 1;
analysis.c:10:2: note: ------>vectorizing statement: ivtmp_57 = ivtmp_9 - 1;
analysis.c:10:2: note: ------>vectorizing statement: vectp_a.10_72 = vectp_a.10_71 + 16;
analysis.c:10:2: note: ------>vectorizing statement: if (ivtmp_57 != 0)
analysis.c:10:2: note: New loop exit condition: if (ivtmp_75 < 256)
analysis.c:10:2: note: LOOP VECTORIZED

analysis.c:5:5: note: vectorized 3 loops in function.
analysis.c:5:5: note: ===vect_slp_analyze_bb===
analysis.c:6:2: note: === vect_analyze_data_refs ===
analysis.c:6:2: note: got vectype for stmt: _1 = *argv_22(D);
vector(2) long unsigned int
analysis.c:6:2: note: not vectorized: not enough data-refs in basic block.
analysis.c:6:2: note: === vect_analyze_data_refs ===
analysis.c:6:2: note: not vectorized: not enough data-refs in basic block.
analysis.c:6:2: note: ===vect_slp_analyze_bb===
analysis.c:11:8: note: === vect_analyze_data_refs ===
analysis.c:11:8: note: not vectorized: no vectype for stmt: MEM[(int *)vectp_a.10_71] = vect_cst__41;
 scalar_type: vector(4) int
analysis.c:11:8: note: not vectorized: not enough data-refs in basic block.
analysis.c:11:8: note: ===vect_slp_analyze_bb===
analysis.c:11:8: note: ===vect_slp_analyze_bb===
analysis.c:11:8: note: ===vect_slp_analyze_bb===
analysis.c:15:8: note: === vect_analyze_data_refs ===
analysis.c:15:8: note: not vectorized: no vectype for stmt: vect__2.7_15 = MEM[(int *)vectp_a.5_17];
 scalar_type: vector(4) int
analysis.c:15:8: note: not vectorized: no vectype for stmt: MEM[(int *)vectp_b.8_46] = vect__2.7_15;
 scalar_type: vector(4) int
analysis.c:15:8: note: === vect_analyze_data_ref_accesses ===
analysis.c:15:8: note: not vectorized: no grouped stores in basic block.
analysis.c:15:8: note: ===vect_slp_analyze_bb===
analysis.c:15:8: note: ===vect_slp_analyze_bb===
analysis.c:15:8: note: === vect_analyze_data_refs ===
analysis.c:15:8: note: not vectorized: not enough data-refs in basic block.
analysis.c:15:8: note: ===vect_slp_analyze_bb===
analysis.c:19:12: note: === vect_analyze_data_refs ===
analysis.c:19:12: note: not vectorized: no vectype for stmt: vect__4.2_52 = MEM[(int *)vectp_a.0_56];
 scalar_type: vector(4) int
analysis.c:19:12: note: not vectorized: no vectype for stmt: MEM[(int *)vectp_a.3_50] = vect__4.2_52;
 scalar_type: vector(4) int
analysis.c:19:12: note: === vect_analyze_data_ref_accesses ===
analysis.c:19:12: note: not vectorized: no grouped stores in basic block.
analysis.c:19:12: note: ===vect_slp_analyze_bb===
analysis.c:19:12: note: ===vect_slp_analyze_bb===
analysis.c:19:12: note: ===vect_slp_analyze_bb===
analysis.c:22:2: note: === vect_analyze_data_refs ===
analysis.c:22:2: note: got vectype for stmt: _6 = a[_5];
vector(4) int
analysis.c:22:2: note: got vectype for stmt: a[i_62] = _6;
vector(4) int
analysis.c:22:2: note: === vect_analyze_data_ref_accesses ===
analysis.c:22:2: note: not consecutive access _6 = a[_5];
analysis.c:22:2: note: not consecutive access a[i_62] = _6;
analysis.c:22:2: note: not vectorized: no grouped stores in basic block.
analysis.c:22:2: note: ===vect_slp_analyze_bb===
analysis.c:22:2: note: ===vect_slp_analyze_bb===
analysis.c:22:2: note: ===vect_slp_analyze_bb===
analysis.c:28:3: note: === vect_analyze_data_refs ===
analysis.c:28:3: note: got vectype for stmt: _7 = a[i_63];
vector(4) int
analysis.c:28:3: note: not vectorized: not enough data-refs in basic block.
analysis.c:27:2: note: === vect_analyze_data_refs ===
analysis.c:27:2: note: not vectorized: not enough data-refs in basic block.
analysis.c:27:2: note: ===vect_slp_analyze_bb===
analysis.c:27:2: note: ===vect_slp_analyze_bb===
analysis.c:30:5: note: ===vect_slp_analyze_bb===
analysis.c:32:9: note: === vect_analyze_data_refs ===
analysis.c:32:9: note: got vectype for stmt: _8 = b[i_64];
vector(4) int
analysis.c:32:9: note: not vectorized: not enough data-refs in basic block.
analysis.c:31:2: note: === vect_analyze_data_refs ===
analysis.c:31:2: note: not vectorized: not enough data-refs in basic block.
analysis.c:31:2: note: ===vect_slp_analyze_bb===
analysis.c:31:2: note: ===vect_slp_analyze_bb===
analysis.c:5:5: note: === vect_analyze_data_refs ===
analysis.c:5:5: note: not vectorized: not enough data-refs in basic block.

Process finished with exit code 0

Building 'analysis' finished